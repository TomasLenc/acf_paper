---
title: "Autocorrelation LowHigh"
author: "Tomas Lenc"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output:
  html_document: 
    code_folding: hide
    toc: true
    toc_float: 
      collapsed: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

source('config.R')
source('figures.R')
source('utils.R')

```


```{r}

ap_fit_method <- 'irasa'

rhythms <- c('unsyncopated', 'syncopated')
tones <- c('L', 'H')

data_path = file.path(experiment_path, 'data')

df_eeg_boot <- read.csv(file.path(data_path,
                                  sprintf('exp-lowhigh_apFitMethod-%s_eegBoot.csv', ap_fit_method)))

df_eeg_grand <- read.csv(file.path(data_path, 
                                  sprintf('exp-lowhigh_apFitMethod-%s_eegGrand.csv', ap_fit_method)))

df_eeg_ind <- read.csv(file.path(data_path, 
                                  sprintf('exp-lowhigh_apFitMethod-%s_eegIndividual.csv', ap_fit_method)))

df_eeg_boot$rhythm <- factor(df_eeg_boot$rhythm,  levels=rhythms)
df_eeg_grand$rhythm <- factor(df_eeg_grand$rhythm,  levels=rhythms)
df_eeg_ind$rhythm <- factor(df_eeg_ind$rhythm,  levels=rhythms)

df_eeg_boot$tone <- factor(df_eeg_boot$tone,  levels=tones)
df_eeg_grand$tone <- factor(df_eeg_grand$tone,  levels=tones)
df_eeg_ind$tone <- factor(df_eeg_ind$tone,  levels=tones)

# load matlab parameters 
library(R.matlab)
par_matlab <- drop(readMat(file.path(data_path, 
                                  sprintf('exp-lowhigh_apFitMethod-%s_eegBoot_par.mat',
                                          ap_fit_method)), fixNames=FALSE)$par)


```


<br>

### EEG individual 

```{r}

cols <- c(L='red', H='blue')
cols_individual <- lighten(cols, amount=0.7)
names(cols_individual) <- names(cols)

# df <- df_eeg_ind
# col_name_eeg='z_meter_acf_subtr'
# col_name_coch='z_meter_acf_sound'

plot_feat_ind <- function(df, 
                         col_name_eeg='z_meter_fft_subtr', col_name_coch='z_meter_fft_sound'){
    
    df$x <- as.numeric(df$tone)
    df$x_coch_start <- df$x-0.3
    df$x_coch_end <- df$x+0.3
    
    df_summary <- summarySE(df, groupvars=c('rhythm', 'tone'), measurevar=col_name_eeg)
    
    df_summary$x <- as.numeric(df_summary$tone)
    
    p <- ggplot(df, aes(x, .data[[col_name_eeg]], color=tone)) + 
        geom_segment(data=df[df$subject==df$subject[1],],
                     inherit.aes=FALSE,
                     aes(x=x_coch_start, xend=x_coch_end,
                         y=.data[[col_name_coch]], yend=.data[[col_name_coch]],
                         color=tone),
                     linewidth=3, alpha=0.5) +
        scale_color_manual(name='tone', values=cols) +
        scale_x_continuous(breaks=c(1:length(levels(df$tone))), 
                           labels=levels(df$tone)) +  
        new_scale_color() + new_scale_fill() +
        geom_point(aes(color=tone), size=2, position=position_jitter(width=0.1, height=0)) +
        scale_color_manual(name='tone', values=cols_individual) + 
        geom_hline(yintercept=0) +
        new_scale_color() + new_scale_fill() + 
        geom_point(data=df_summary, aes(color=tone), size=3) + 
        geom_errorbar(data=df_summary, 
                      aes(color=tone, ymin=.data[[col_name_eeg]]-ci,
                          ymax=.data[[col_name_eeg]]+ci), 
                      linewidth=1, width=0.2) + 
        scale_color_manual(name='tone', values=cols) + 
        facet_wrap(~rhythm, nrow=1) + 
        theme_cowplot() + 
        my_theme()
    
    return(p)
}


# df <- df_eeg_grand
# df_boot <- df_eeg_boot
# col_name_eeg='z_meter_fft_subtr'
# col_name_coch='z_meter_fft_sound'

plot_feat_boot <- function(df, df_boot, 
                           col_name_eeg='z_meter_fft_subtr', col_name_coch='z_meter_fft_sound'){

    df$x <- as.numeric(df$tone)
    df$x_coch_start <- df$x-0.4
    df$x_coch_end <- df$x+0.4
    
    df_boot$x <- as.numeric(df_boot$tone)
    
    df_ci <- df_boot %>% 
        group_by(tone, rhythm) %>% 
        group_modify(~ get_boot_summary(.x, .y, feature_name=col_name_eeg)) 
        
    df_summary <- join(df_ci, 
                       df %>% select(tone, rhythm, x, 
                                     x_coch_start, x_coch_end, 
                                     .data[[col_name_eeg]], .data[[col_name_coch]]), 
                       by=c('tone', 'rhythm'))
    
    p <- ggplot(df_summary, aes(x, .data[[col_name_eeg]], color=tone)) + 
        geom_segment(aes(x=x_coch_start, xend=x_coch_end,
                         y=.data[[col_name_coch]], yend=.data[[col_name_coch]],
                         color=tone),
                     linewidth=3, alpha=0.5) +
        scale_color_manual(name='tone', values=cols)+
        scale_fill_manual(name='tone', values=cols) +
        scale_x_continuous(breaks=c(1:length(levels(df$tone))), 
                           labels=levels(df$tone)) +  
        geom_half_violin(data=df_boot, aes(fill=tone, group=tone), 
                         side='l', scale='width', fill='grey60', color=NA, alpha=0.6, trim=T) + 
        geom_hline(yintercept=0) +
        geom_point(aes(x=x+0.15, color=tone), size=3) + 
        geom_errorbar(aes(x=x+0.15, color=tone, ymin=ci_low, ymax=ci_high), 
                      size=1, width=0) + 
        facet_wrap(~rhythm, nrow=1) + 
        theme_cowplot() + 
        my_theme()
    
    return(p)
}

```

<br> 

Individual participant data. 1/f component was estimated using `r ap_fit_method` method, separately for each electrode and participant. 

After subtracting the 1/f, acf was computed and averaged across **all** channels, separately for each participant.  

The zscore at meter-related lags was computed from the channel-averaged ACF, separately for each participant and condition.  

Lags of interest were seleted as follows:   

**Meter-related**: `r par_matlab$lags_meter_rel`

**Meter-unrelated**: `r par_matlab$lags_meter_unrel`


```{r}
plot_feat_ind(df_eeg_ind, 
              col_name_eeg='z_meter_acf_subtr',
              col_name_coch='z_meter_acf_sound')
```
<br> 

Mixed model (factors: rhythm x tone)

```{r}
m <- lmer(z_meter_acf_subtr ~ rhythm * tone + (1|subject), data=df_eeg_ind)
pander(Anova(m))
```
<br> 

Posthoc t-test low vs. high tone  (bonferroni corrected): 

```{r}

ttest_tone <- function(df, var_name){
    vals_low <- df %>% filter(tone == 'L') %>% arrange(subject) %>% pull(.data[[var_name]])
    vals_high <- df %>% filter(tone == 'H') %>% arrange(subject) %>% pull(.data[[var_name]])
    res <- t.test(vals_low, vals_high, paired=T)
    data.frame(t=res$statistic, p=res$p.value)
}

df_posthoc <- df_eeg_ind %>% 
    group_by(rhythm) %>% 
    group_modify(~ttest_tone(.x, var_name='z_meter_acf_subtr'))

df_posthoc$p <- p.adjust(df_posthoc$p, method='bonferroni')

pander(df_posthoc)
```
<br> 

T-test against 0 (fdr corrected): 
```{r}

ttest_0 <- function(df, var_name){
    vals_eeg <- df %>% pull(.data[[var_name]])
    res <- t.test(vals_eeg, mu=0, alternative='greater')
    data.frame(t=res$statistic, p=res$p.value)
}

df_posthoc <- df_eeg_ind %>% 
    group_by(rhythm, tone) %>% 
    group_modify(~ttest_0(.x, var_name='z_meter_acf_subtr'))

df_posthoc$p <- p.adjust(df_posthoc$p, method='fdr')

pander(df_posthoc)
```



<br><br><br> 

### EEG bootstrapped 

Grand average was computed by averaging time-domain responses across all participants, separately for each condition and channel.  

Then, 1/f-subtracted acf was computed and averaged across all channels, and zscore at meter-related lags was computed. 

To estimate confidence intervals of the grand-average values, bootrapping was used. On each bootstrap iteration (N=`r par_matlab$n_boot` per condition), 14 participants were chosen with repetition, and analysed the same way as the true grand average above.  

```{r}
plot_feat_boot(df_eeg_grand, 
              df_eeg_boot, 
              col_name_eeg='z_meter_acf_subtr',
              col_name_coch='z_meter_acf_sound')

```









