---
title: "ACF report"
author: "Tomas Lenc"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output:
  html_document: 
    code_folding: hide
    toc: true
    toc_float: 
      collapsed: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

source('config.R')
source('figures.R')
source('utils.R')

```


This report puts all the simulation and analysis results together! 

```{r}
# load matlab parameters 
par_matlab <- drop(R.matlab::readMat(file.path(data_path, 'ir-square_ir.mat'), fixNames=FALSE)$par)

```


Frequencies of interest for FFT were selected as follows:   

**Meter-related freqs**: `r round(par_matlab$freq_meter_rel, 2)` Hz. 

**Meter-unrelated freqs**: `r round(par_matlab$freq_meter_unrel, 2)` Hz. 

<br> 

Lags of interest for ACF were selected as follows:   

**Meter-related lags**: `r round(par_matlab$lags_meter_rel, 2)` s. 

**Meter-unrelated lags**: `r round(par_matlab$lags_meter_unrel, 2)` s.  

<br>  



```{r, fig.align="center"}
fname <- file.path(data_path, 'ir-square_ir.svg')
knitr::include_graphics(fname)
```


```{r, fig.align="center"}
fname <- file.path(data_path, 'ir-square_emph.svg')
knitr::include_graphics(fname)
```


```{r, fig.align="center"}
fname <- file.path(data_path, 'ir-square_apFitMethod-irasa_onlyHarm-true_jitter.svg')
knitr::include_graphics(fname)
```



<br><br><br><br>  

---  
# Effect of noise  

<br> 



```{r, fig.align="center"}
fname <- file.path(data_path, 'ir-square_noise-eeg_apFitMethod-irasa_onlyHarm-true_snr.svg')
knitr::include_graphics(fname)
```


Noise is bad because it distorts the shape of the FFT or ACF, creating a bias in the estimated 
meter zscore. 

This can be easily demonstrated by applying the estiamation method to pure noise without any signal. 

When we repeat this simulation many times, we see that simply applying the frequency-tagging or 
periodicity-tagging method leads to, on average, non-zero meter zscore. 

To address this issue, there are ways to account for the noise and minimize the bias:   

* FFT -> subtracting neighboring bins in the magnitude spectrum.  
* ACF -> estimating the 1/f noise and subtracting this estimate from the spectrum before computing the ACF.  


```{r}

fname <- 'ir-square_noise-eeg_apFitMethod-irasa_onlyHarm-true_onlyNoise.csv'

df_only_noise <- read.csv(file.path(data_path, fname))

df_only_noise$sample <- seq(1, nrow(df_only_noise))
    
df_only_noise_long <- pivot_longer(df_only_noise,
                                   !sample, 
                                   names_to='method',
                                   values_to='z_meter')

get_bf <- function(df) {
       bf <- BayesFactor::ttestBF(df$z_meter, mu=0)
       data.frame(bf10 = sprintf('BF10=%.3g', as.vector(bf)),
                  z_meter=0.05 + max(df$z_meter))
}

df_bf <- df_only_noise_long %>% 
    group_by(method) %>%
    group_modify(~ get_bf(.x))

df_summary <- summarySE(data=df_only_noise_long, measurevar='z_meter', groupvars=c('method'))

p <- ggplot(df_only_noise_long, aes(x=1, y=z_meter)) + 
    geom_hline(yintercept=0, color='black', linetype='dashed') + 
    geom_half_violin(side='l', scale='width', fill='grey70', color=NA) + 
    geom_half_point(side='r', color='grey50', alpha=0.1) + 
    geom_point(data=df_summary, size=2, color='black') + 
    geom_errorbar(data=df_summary, aes(ymin=z_meter-sd, ymax=z_meter+sd),
                  color='black', linewidth=0.8, width=0) + 
    geom_text(data=df_bf, aes(label=bf10)) + 
    scale_x_continuous(breaks=c()) + 
    facet_wrap(~method, nrow=1, scales='free_y') + 
    theme_cowplot() + 
    theme(
        axis.title.x = element_blank(),
        axis.line.x = element_blank()
    )


save_fig(file.path(data_path, fname), p, width=6, height=3)
p
```




<br><br>

## Zscore: pulled to zero by noise

This is problematic, since systematically different magnitude of noise across conditions can lead to 
spurious statistical differences in the estimated meter zscores. 

We have to minimize the effect of noise as much as possible (in reality there is no way to simply get 
rid of the influence of noise - we can only suppress it to greater/lesser degree).  

```{r}

fname <- 'irType-square_apFitMethod-irasa_onlyHarm-true_noiseEffectZscoreACFvsFFT.csv'

df_noise_effect_z <- read.csv(file.path(data_path, fname))

# convert to factors
df_noise_effect_z$pat <- factor(df_noise_effect_z$pat)
df_noise_effect_z$selected_for <- factor(df_noise_effect_z$selected_for,
                                         levels=(c('fft', 'acf')))

# convert to long format so that we can use the method and/or whether noise was subtracted as an
# independent variable 
df <- pivot_longer(df_noise_effect_z,
                   !c(pat, selected_for, snr, sample, z_snr, z_meter_fft_orig, z_meter_acf_orig), 
                   names_to='var_name',
                   values_to='z_meter')

# some magic to create new variable columns about the method 
df$method <- ifelse(str_detect(df$var_name, 'fft'), 'fft', 'acf')
df$subtr <- ifelse(str_detect(df$var_name, 'subtr'), 'yes', 'no')
df$subtr <- factor(df$subtr, levels=c('no', 'yes'))

# more factors
df$snr <- factor(df$snr)
df$snr <- factor(df$snr, levels=rev(levels(df$snr)))

mask_fft <- df$selected_for == 'fft'
df$z_meter_orig <- rep(NA, 1, nrow(df))
df$z_meter_orig[mask_fft] <- df$z_meter_fft_orig[mask_fft]
df$z_meter_orig[!mask_fft] <- df$z_meter_acf_orig[!mask_fft]

# # confirm that it works with different patterns too
# p_fft_high_z <- plot_subtr_effect(df, method='fft', pats=c(7, 17))
# p_acf_high_z <- plot_subtr_effect(df, method='acf', pats=c(7, 17))
# 
# p_fft_low_z <- plot_subtr_effect(df, method='fft', pats=c(2, 11))
# p_acf_low_z <- plot_subtr_effect(df, method='acf', pats=c(2, 11))

# pick a pattern with high positive true zscore
p_fft_high_z <- plot_subtr_effect(df, method='fft', pats=c(8, 18))
p_acf_high_z <- plot_subtr_effect(df, method='acf', pats=c(8, 18))
# pick a pattern with low negative true zscore
p_fft_low_z <- plot_subtr_effect(df, method='fft', pats=c(1, 10))
p_acf_low_z <- plot_subtr_effect(df, method='acf', pats=c(1, 10))

# extract a legend that is laid out horizontally
legend <- get_legend(p_fft_high_z + 
                         guides(color = guide_legend(nrow = 1)) +
                         theme(legend.position="top"))
# merge plots 
p_merged <- plot_grid(
    p_fft_high_z + theme(legend.position="none"), 
    p_acf_high_z + theme(legend.position="none"), 
    p_fft_low_z + theme(legend.position="none"), 
    p_acf_low_z + theme(legend.position="none"), 
    nrow=2, ncol=2)

p <- plot_grid(legend, p_merged, ncol=1, rel_heights=c(0.1, 1))

save_fig(file.path(data_path, fname), p, width=7, height=5)
p


```


In the analysis above, we have picked a pattern that yielded a high (or low) meter zscore separately
for the FFT and for the ACF. This is because it turns out quite difficult to find a pattern that 
yields very similar zscore (in absolute terms) between the FFT and ACF. 

The zscores yielded by the two methods are still higly correlated though, but the absolute scale of 
meter zscores obtained from the $ method is smaller. 

Nevertheless, the next question is: which is more sensitive to noise, FFT or ACF?  


<br><br>

## Noise: FFT vs. ACF


A better way than looking at meter zscores (which are sensitive to the selection of frequencies/lags 
of interest as meter-related), we can look at the values across all freqs/lags of interest.  

simply assess the distance from the ground truth

This way, we can use the exact same patterns for the FFT and ACF (no need to worry about the actual 
value of meter zscore in he ground truth signal).


```{r}

# load simulated data
fname <- 'irType-square_apFitMethod-irasa_onlyHarm-true_noiseEffectDistACFvsFFT.csv'
df <- read.csv(file.path(data_path, fname))

p <- plot_dist_to_truth(df, 
                        df_eeg_z_snr=NULL)

save_fig(file.path(data_path, fname), p, width=5, height=3)
p

```


Let's focus only on the ACF. 

We can plot the same ground-truth correlation data after binning the observed SNR and estimating 
distribution density within each bin interval.   

We will place the log SNR slices such that one of them is exactly centered at the log z_snr observed 
in the EEG dataset (either lowhigh or infant).  

This way we can get a better idea where we are in therm of surface EEG data quality and what we can 
expect in terms of reconstructing the ground truth ACF values.  

Of course, keep in mind that this simulation is done with a square impulse response kernel and resting-state
EEG noise from a different dataset than lowhigh. That means the shape of the noise, as well as the 
unitary response will be different between the simulated data and lowhigh eeg, making the z_snr values
estimated from the first 11 harmonics harder to directly compare.  

Let's save the output into png files. 

```{r}

# FFT

fname <- 'irType-square_apFitMethod-irasa_onlyHarm-true_noiseEffectDistACFvsFFT.csv'
df <- read.csv(file.path(data_path, fname))

fname_eeg <- 'exp-lowhigh_apFitMethod-irasa_onlyHarm-true_roi-frontocentral_eegIndividual.csv'
df_eeg_ind <- read.csv(file.path(data_path, fname_eeg))
p <- plot_dist_to_truth_density(df, 
                                y_var_name='r_fft_subtr',
                                df_eeg_z_snr=df_eeg_ind)
fname_fig <- tools::file_path_sans_ext(fname)
fname_fig_elems <- unlist(str_split(fname_fig, '_'))
fname_fig_elems[length(fname_fig_elems)] <- 'exp-lowhigh_noiseEffectDistFFT'
fname_fig <- paste(fname_fig_elems, collapse='_')
save_fig(file.path(data_path, fname_fig), p, width=5, height=3)

fname_eeg <- 'exp-infant_apFitMethod-irasa_onlyHarm-true_roi-front_eegIndividual.csv'
df_eeg_ind <- read.csv(file.path(data_path, fname_eeg))
p <- plot_dist_to_truth_density(df, 
                                y_var_name='r_fft_subtr',
                                df_eeg_z_snr=df_eeg_ind)
fname_fig <- tools::file_path_sans_ext(fname)
fname_fig_elems <- unlist(str_split(fname_fig, '_'))
fname_fig_elems[length(fname_fig_elems)] <- 'exp-infant_noiseEffectDistFFT'
fname_fig <- paste(fname_fig_elems, collapse='_')
save_fig(file.path(data_path, fname_fig), p, width=5, height=3)




# ACF

fname <- 'irType-square_apFitMethod-irasa_noiseEffectDistAllVsOnlyHarm.csv'
df <- read.csv(file.path(data_path, fname))

fname_eeg <- 'exp-lowhigh_apFitMethod-irasa_onlyHarm-true_roi-frontocentral_eegIndividual.csv'
df_eeg_ind <- read.csv(file.path(data_path, fname_eeg))
p <- plot_dist_to_truth_density(filter(df, method=='raw'), 
                                y_var_name='r',
                                df_eeg_z_snr=df_eeg_ind)
fname_fig <- tools::file_path_sans_ext(fname)
fname_fig_elems <- unlist(str_split(fname_fig, '_'))
fname_fig_elems[length(fname_fig_elems)] <- 'method-raw_exp-lowhigh_noiseEffectDistACF'
fname_fig <- paste(fname_fig_elems, collapse='_')
save_fig(file.path(data_path, fname_fig), p, width=5, height=3)


fname_eeg <- 'exp-infant_apFitMethod-irasa_onlyHarm-true_roi-front_eegIndividual.csv'
df_eeg_ind <- read.csv(file.path(data_path, fname_eeg))
p <- plot_dist_to_truth_density(filter(df, method=='raw'),  
                                y_var_name='r',
                                df_eeg_z_snr=df_eeg_ind)
fname_fig <- tools::file_path_sans_ext(fname)
fname_fig_elems <- unlist(str_split(fname_fig, '_'))
fname_fig_elems[length(fname_fig_elems)] <- 'method-raw_exp-infant_noiseEffectDistACF'
fname_fig <- paste(fname_fig_elems, collapse='_')
save_fig(file.path(data_path, fname_fig), p, width=5, height=3)


p <- plot_dist_to_truth_density(filter(df, method=='subtr'), 
                                y_var_name='r')
fname_fig <- tools::file_path_sans_ext(fname)
fname_fig_elems <- unlist(str_split(fname_fig, '_'))
fname_fig_elems[length(fname_fig_elems)] <- 'method-subtr'
fname_fig <- paste(fname_fig_elems, collapse='_')
save_fig(file.path(data_path, fname_fig), p, width=5, height=3)

p <- plot_dist_to_truth_density(filter(df, method=='subtr_only_harm'), 
                                y_var_name='r')
fname_fig <- tools::file_path_sans_ext(fname)
fname_fig_elems <- unlist(str_split(fname_fig, '_'))
fname_fig_elems[length(fname_fig_elems)] <- 'method-subtrOnlyHarm'
fname_fig <- paste(fname_fig_elems, collapse='_')
save_fig(file.path(data_path, fname_fig), p, width=5, height=3)

```




<br><br>

## Noise: raw, subtr, only harmonics


```{r}

fname <- 'irType-square_apFitMethod-irasa_noiseEffectDistAllVsOnlyHarm.csv'

df <- read.csv(file.path(data_path, fname))

# convert to factors
df$pat <- factor(df$pat)
df$method <- factor(df$method, levels=c('raw', 'subtr', 'subtr_only_harm'))

# fix negative values before taking log 
df <- filter(df, z_snr > 0)

# # fisher-transform the correlation coefficients
df$z <- r_to_z(df$r)

# fit sigmoids
df_raw <- filter(df, method=='raw')
m_raw <- fit_sigm(log10(df_raw$z_snr), df_raw$r,
                  init_params=list('min_'=0, 'max_'=1, 'x50_'=1.4, 'slope_'=2)
                  )

df_subtr <- filter(df, method=='subtr')
m_subtr <- fit_sigm(log10(df_subtr$z_snr), df_subtr$r, 
                    init_params=list('min_'=0, 'max_'=1, 'x50_'=1.4, 'slope_'=2)
                    )

df_subtr_only_harm <- filter(df, method=='subtr_only_harm')
m_subtr_only_harm <- fit_sigm(log10(df_subtr_only_harm$z_snr), df_subtr_only_harm$r, 
                              init_params=list('min_'=0, 'max_'=1, 'x50_'=1.4, 'slope_'=3)
                              # init_params=list('min_'=0, 'max_'=1, 'x50_'=1.4, 'slope_'=2)
                              )

cols <- c('raw'='#711885', 
          'subtr'='#d18624', 
          'subtr_only_harm'='#2b7557')

# plot 
p <- ggplot() +
    geom_point(data=df_raw, aes(log10(z_snr), r), 
               color=lighten(cols['raw'], 0.2), alpha=0.2) + 
    geom_point(data=df_subtr, aes(log10(z_snr), r), 
               color=lighten(cols['subtr'], 0.2), alpha=0.2) + 
    geom_point(data=df_subtr_only_harm, aes(log10(z_snr), r), 
               color=lighten(cols['subtr_only_harm'], 0.2), alpha=0.2) + 
    geom_function(fun=sigm, args=coef(m_raw), aes(color='raw'), linewidth=2) +
    geom_function(fun=sigm, args=coef(m_subtr), aes(color='subtr'), linewidth=2) +
    geom_function(fun=sigm, args=coef(m_subtr_only_harm), aes(color='subtr_only_harm'), linewidth=2) +
    geom_hline(yintercept = 0, color='#000000') + 
    scale_color_manual(name='method', values=cols) + 
    scale_y_continuous(limits=c(-1, 1), breaks=c(-1, 0, 1)) + 
    ylab('r with ground truth') + 
    theme_cowplot() +
    scale_x_reverse() 

save_fig(file.path(data_path, fname), p, width=7, height=4)
p

```


And here are the parameter estimates for the model fitted to the raw ACF:  

<br> 


```{r}
knitr::kable(render_sigmoid_fit(m_raw))
```

To the noise-subtracted ACF:  

```{r}
knitr::kable(render_sigmoid_fit(m_subtr))
```

And to the noise-subtracted ACF after only pattern harmonics were taken:  

```{r}
knitr::kable(render_sigmoid_fit(m_subtr_only_harm))
```






<br><br><br>


## Noise: band width




```{r, fig.height=15, fig.width=5}

fname <- 'irType-square_apFitMethod-irasa_noiseEffectDistBand.csv'
df <- read.csv(file.path(data_path, fname))
df$bandwidth <- factor(round(df$bandwidth, 2))

bands <- levels(df$bandwidth)

ps <- vector(mode="list", length=length(bands) + 1)

p <- plot_dist_to_truth_density(filter(df, bandwidth == bands[1]), 
                            y_var_name='r_raw')
ps[[1]] <- p

for (i_band in c(1:length(bands))){
    p <- plot_dist_to_truth_density(filter(df,  bandwidth == bands[i_band]), 
                                y_var_name='r_subtr')
    p <- p + 
        theme(axis.text.x = element_blank(), 
              axis.title.x <- element_blank()) + 
        ggtitle(sprintf('band: %s Hz', bands[i_band]))
    ps[[i_band + 1]] <- p
}

do.call(plot_grid, c(ps, ncol=1))


# fname_fig <- tools::file_path_sans_ext(fname)
# fname_fig_elems <- unlist(str_split(fname_fig, '_'))
# fname_fig_elems[length(fname_fig_elems)] <- 'method-raw_exp-lowhigh_noiseEffectDistACF'
# fname_fig <- paste(fname_fig_elems, collapse='_')
# save_fig(file.path(data_path, fname_fig), p, width=5, height=3)

```








---


<br><br><br>


# Real data 

Let's test how the method works on real data now.  


<br><br>

## EEG: LowHigh experiment


```{r}

rhythms <- c('unsyncopated', 'syncopated')
tones <- c('L', 'H')

fname_lowhigh <- 'exp-lowhigh_apFitMethod-irasa_onlyHarm-true_roi-frontocentral_eegIndividual.csv'
# fname_lowhigh <- 'exp-lowhigh_apFitMethod-irasa_onlyHarm-true_roi-all_eegIndividual.csv'

df_eeg_ind <- read.csv(file.path(data_path, fname_lowhigh))

df_eeg_ind$rhythm <- factor(df_eeg_ind$rhythm,  levels=rhythms)
df_eeg_ind$tone <- factor(df_eeg_ind$tone,  levels=tones)

# cols <- c(L='#b52c0d', H='#1058b0')
cols <- c(L='#742b82ff', H='#a65a03ff')

cols_individual <- lighten(cols, amount=0.7)
names(cols_individual) <- names(cols)

```


```{r}

# some functions we'll reuse

# df <- df_eeg_ind
# col_name_eeg='z_meter_acf_subtr'
# col_name_coch='z_meter_acf_sound'



```

### FFT

Analysis performed on a frontal cluster of channels to get better SNR.   

```{r, fig.width=2.3, fig.height=1.5}
p <- plot_feat_ind_lowhigh(df_eeg_ind, 
              col_name_eeg='z_meter_fft_subtr',
              col_name_coch='z_meter_fft_sound')

fname <- sprintf('%s_FFT', tools::file_path_sans_ext(fname_lowhigh))
save_fig(file.path(data_path, fname), p, width=2.3, height=1.4)
p

```
<br> 

Mixed model (factors: rhythm x tone)

```{r}
m <- lmer(z_meter_fft_subtr ~ rhythm * tone + (1|subject), data=df_eeg_ind)
a <- Anova(m)
knitr::kable(a)
```
<br> 

Posthoc tests low vs. high tone: 

```{r}
if (a[which(rownames(a) == 'rhythm:tone'), "Pr(>Chisq)"] < 0.05){
    
    df_posthoc <- df_eeg_ind %>% 
        group_by(rhythm) %>%
        group_modify(~posthoc_ttest_low_vs_high(.x, var_name_eeg='z_meter_fft_subtr'))
    
    df_posthoc$p <- p.adjust(df_posthoc$p, 'bonferroni')
    knitr::kable(df_posthoc)
    
} else if (a[which(rownames(a) == 'tone'), "Pr(>Chisq)"] < 0.05) {
    
    m_posthoc <- lmer(z_meter_fft_subtr ~ rhythm + tone + (1|subject), data=df_eeg_ind)
    emm <- emmeans(m_posthoc, 'tone')
    c <- contrast(emm, 'pairwise', adjust='bonferroni')
    knitr::kable(as.data.frame(c))
    
} else {
    
    print('no effect including tone signifianct...')

}
```
<br> 

T-test against 0 (fdr corrected): 
```{r}

df_posthoc <- df_eeg_ind %>% 
    group_by(rhythm, tone) %>% 
    group_modify(~ttest_0(.x, var_name='z_meter_fft_subtr'))

df_posthoc$p <- p.adjust(df_posthoc$p, method='fdr')

(df_posthoc)
```



<br><br><br> 

### ACF

Noise-subtracted acf was computed and averaged across **frontocentral** channels, separately for each participant.  

The zscore at meter-related lags was computed from the channel-averaged ACF, separately for each participant and condition.  

```{r, fig.width=2.3, fig.height=1.5}
p <- plot_feat_ind_lowhigh(df_eeg_ind, 
              col_name_eeg='z_meter_acf_subtr',
              col_name_coch='z_meter_acf_sound')

fname <- sprintf('%s_ACF', tools::file_path_sans_ext(fname_lowhigh))
save_fig(file.path(data_path, fname), p, width=2.3, height=1.4)
p
```
<br> 

Mixed model (factors: rhythm x tone)

```{r}
m <- lmer(z_meter_acf_subtr ~ rhythm * tone + (1|subject), data=df_eeg_ind)
a <- Anova(m)
knitr::kable(a)
```
<br> 

Posthoc tests low vs. high tone: 

```{r}
if (a[which(rownames(a) == 'rhythm:tone'), "Pr(>Chisq)"] < 0.05){
    
    df_posthoc <- df_eeg_ind %>% 
        group_by(rhythm) %>%
        group_modify(~posthoc_ttest_low_vs_high(.x, var_name_eeg='z_meter_acf_subtr'))
    
    df_posthoc$p <- p.adjust(df_posthoc$p, 'bonferroni')
    knitr::kable(df_posthoc)
    
} else if (a[which(rownames(a) == 'tone'), "Pr(>Chisq)"] < 0.05) {
    
    m_posthoc <- lmer(z_meter_acf_subtr ~ rhythm + tone + (1|subject), data=df_eeg_ind)
    emm <- emmeans(m_posthoc, 'tone')
    c <- contrast(emm, 'pairwise', adjust='bonferroni')
    knitr::kable(as.data.frame(c))

} else {
    
    print('no effect including tone signifianct...')
    
}

```

<br> 

T-test against 0 (fdr corrected): 
```{r}

df_posthoc <- df_eeg_ind %>% 
    group_by(rhythm, tone) %>% 
    group_modify(~ttest_0(.x, var_name='z_meter_acf_subtr'))

df_posthoc$p <- p.adjust(df_posthoc$p, method='fdr')

knitr::kable(df_posthoc)
```


### Correlation FFT~ACF

```{r}

res <- cor.test(df_eeg_ind$z_meter_fft_subtr, 
                df_eeg_ind$z_meter_acf_subtr, 
                method='pearson')

p <- plot_correlation_scatter(df_eeg_ind, 
                              'z_meter_fft_subtr',
                              'z_meter_acf_subtr',
                              corr_result=res, 
                              bins=15)


fname <- sprintf('%s_corrFftAcf', tools::file_path_sans_ext(fname_lowhigh))
save_fig(file.path(data_path, fname), p, width=4, height=4)
p

```




<br><br>

## TAPPING: LowHigh experiment


```{r}
fname_lowhigh <- 'exp-lowhigh_apFitMethod-irasa_onlyHarm-true_tapIndividual.csv'

df_tap_ind <- read.csv(file.path(data_path, fname_lowhigh))

df_tap_ind$rhythm <- factor(df_tap_ind$rhythm,  levels=rhythms)
df_tap_ind$tone <- factor(df_tap_ind$tone,  levels=tones)

```


### Correlation FFT~ACF

```{r}

res <- cor.test(df_tap_ind$z_meter_fft_subtr, 
                df_tap_ind$z_meter_acf_subtr, 
                method='pearson')

p <- plot_correlation_scatter(df_tap_ind, 
                              'z_meter_fft_subtr',
                              'z_meter_acf_subtr',
                              corr_result=res, 
                              bins=15)

fname <- sprintf('%s_corrFftAcf', tools::file_path_sans_ext(fname_lowhigh))
save_fig(file.path(data_path, fname), p, width=4, height=4)
p

```





<br><br>

## EEG: Infant experiment

```{r}

rhythms <- c('unsync', 'sync')
tones <- c('low', 'high')

fname_lowhigh <- 'exp-infant_apFitMethod-irasa_onlyHarm-true_roi-front_eegIndividual.csv'

df_eeg_ind <- read.csv(file.path(data_path, fname_lowhigh))

df_eeg_ind$rhythm <- factor(df_eeg_ind$rhythm,  levels=rhythms)
df_eeg_ind$tone <- factor(df_eeg_ind$tone,  levels=tones)

# cols <- c(low='#b52c0d', high='#1058b0')
cols <- c(low='#742b82ff', high='#a65a03ff')

cols_individual <- lighten(cols, amount=0.7)
names(cols_individual) <- names(cols)
```


### FFT

Analysis performed on a frontal cluster of channels to get better SNR.   

```{r}
p <- plot_feat_ind_lowhigh(df_eeg_ind, 
              col_name_eeg='z_meter_fft_subtr',
              col_name_coch='z_meter_fft_sound')

fname <- sprintf('%s_FFT', tools::file_path_sans_ext(fname_lowhigh))
save_fig(file.path(data_path, fname), p, width=2.3, height=1.4)
p
```
<br> 

Mixed model (factors: rhythm x tone)

```{r}
m <- lmer(z_meter_fft_subtr ~ rhythm * tone + (1|subject), data=df_eeg_ind)
a <- Anova(m)
knitr::kable(a)
```
<br> 

Posthoc tests low vs. high tone: 

```{r}
if (a[which(rownames(a) == 'rhythm:tone'), "Pr(>Chisq)"] < 0.05){
    
    df_posthoc <- df_eeg_ind %>% 
        group_by(rhythm) %>%
        group_modify(~posthoc_ttest_low_vs_high(.x, var_name_eeg='z_meter_fft_subtr'))
    
    df_posthoc$p <- p.adjust(df_posthoc$p, 'bonferroni')
    knitr::kable(df_posthoc)
    
} else if (a[which(rownames(a) == 'tone'), "Pr(>Chisq)"] < 0.05) {
    
    m_posthoc <- lmer(z_meter_fft_subtr ~ rhythm + tone + (1|subject), data=df_eeg_ind)
    emm <- emmeans(m_posthoc, 'tone')
    c <- contrast(emm, 'pairwise', adjust='bonferroni')
    knitr::kable(as.data.frame(c))
    
} else {
    
    print('no effect including tone signifianct...')

}
```
<br> 

T-test against 0 (fdr corrected): 
```{r}

df_posthoc <- df_eeg_ind %>% 
    group_by(rhythm, tone) %>% 
    group_modify(~ttest_0(.x, var_name='z_meter_fft_subtr'))

df_posthoc$p <- p.adjust(df_posthoc$p, method='fdr')

knitr::kable(df_posthoc)
```



<br><br><br> 

### ACF

Noise-subtracted acf was computed and averaged across **frontocentral** channels, separately for each participant.  

The zscore at meter-related lags was computed from the channel-averaged ACF, separately for each participant and condition.  

```{r}
p <- plot_feat_ind_lowhigh(df_eeg_ind, 
              col_name_eeg='z_meter_acf_subtr',
              col_name_coch='z_meter_acf_sound')

fname <- sprintf('%s_ACF', tools::file_path_sans_ext(fname_lowhigh))
save_fig(file.path(data_path, fname), p, width=2.3, height=1.4)
p

```
<br> 

Mixed model (factors: rhythm x tone)

```{r}
m <- lmer(z_meter_acf_subtr ~ rhythm * tone + (1|subject), data=df_eeg_ind)
a <- Anova(m)
knitr::kable(a)
```
<br> 

Posthoc tests low vs. high tone: 

```{r}
if (a[which(rownames(a) == 'rhythm:tone'), "Pr(>Chisq)"] < 0.05){
    
    df_posthoc <- df_eeg_ind %>% 
        group_by(rhythm) %>%
        group_modify(~posthoc_ttest_low_vs_high(.x, var_name_eeg='z_meter_acf_subtr'))
    
    df_posthoc$p <- p.adjust(df_posthoc$p, 'bonferroni')
    knitr::kable(df_posthoc)
    
} else if (a[which(rownames(a) == 'tone'), "Pr(>Chisq)"] < 0.05) {
    
    m_posthoc <- lmer(z_meter_acf_subtr ~ rhythm + tone + (1|subject), data=df_eeg_ind)
    emm <- emmeans(m_posthoc, 'tone')
    c <- contrast(emm, 'pairwise', adjust='bonferroni')
    knitr::kable(as.data.frame(c))

} else {
    
    print('no effect including tone signifianct...')
    
}

```

<br> 

T-test against 0 (fdr corrected): 
```{r}

df_posthoc <- df_eeg_ind %>% 
    group_by(rhythm, tone) %>% 
    group_modify(~ttest_0(.x, var_name='z_meter_acf_subtr'))

df_posthoc$p <- p.adjust(df_posthoc$p, method='fdr')

knitr::kable(df_posthoc)
```


### Correlation FFT~ACF

```{r}

res <- cor.test(df_eeg_ind$z_meter_fft_subtr, 
                df_eeg_ind$z_meter_acf_subtr, 
                method='pearson')

p <- plot_correlation_scatter(df_eeg_ind, 
                              'z_meter_fft_subtr',
                              'z_meter_acf_subtr',
                              corr_result=res, 
                              bins=15)


fname <- sprintf('%s_corrFftAcf', tools::file_path_sans_ext(fname_lowhigh))
save_fig(file.path(data_path, fname), p, width=4, height=4)
p

```

















